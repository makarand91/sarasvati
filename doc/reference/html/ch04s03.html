<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Java API</title><link rel="stylesheet" href="../docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Sarasvati - Simple, Capable and Transparent Workflow"><link rel="up" href="ch04.html" title="Chapter 4. Using Sarasvati"><link rel="prev" href="ch04s02.html" title="Sarasvati File Format"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Java API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Using Sarasvati</th><td width="20%" align="right"> </td></tr></table><hr></div><div class="section" title="Java API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-java-api"></a>Java API</h2></div></div></div><p>
      The process definition file format also supports custom elements and
      attributes, but before we discuss that, the API needs to be
      introduced.
    </p><div class="section" title="Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="using-java-api-interfaces"></a>Interfaces</h3></div></div></div><p>
        The main interface for interacting with process definitions and
        processes is
        <code class="literal">Engine</code>
        :
      </p><pre class="programlisting">package com.googlecode.sarasvati;

public interface Engine
{
  GraphProcess startProcess (Graph graph);
  void startProcess (GraphProcess process);
  void cancelProcess (GraphProcess process);
  void finalizeComplete (GraphProcess process);
  void finalizeCancel (GraphProcess process);
  void completeExecution (NodeToken token, String arcName);
  void completeAsynchronous (NodeToken token, String arcName );
  void executeQueuedArcTokens (GraphProcess process);
  GraphRepository&lt;? extends Graph&gt; getRepository ();
  GraphFactory&lt;? extends Graph&gt; getFactory ();
  GraphLoader&lt;? extends Graph&gt; getLoader ();
  void addNodeType (String type, Class&lt;? extends Node&gt; nodeClass );
  void fireEvent (ExecutionEvent event);
  void addExecutionListener (ExecutionListener listener, ExecutionEventType...eventTypes);
  void addExecutionListener (GraphProcess process, ExecutionListener listener, ExecutionEventType...eventTypes);
  void removeExecutionListener (ExecutionListener listener, ExecutionEventType...eventTypes);
  void removeExecutionListener (GraphProcess process, ExecutionListener listener, ExecutionEventType...eventTypes);
  ExecutionListener getExecutionListenerInstance (String type) throws WorkflowException;
  void setupScriptEnv (ScriptEnv env, NodeToken token);
}
</pre><p>
        Process definitions are stored in classes implementing the
        <code class="literal">Graph</code>
        interface.
      </p><pre class="programlisting">package com.googlecode.sarasvati;

public interface Graph
{
  String getName ();
  int getVersion ();
  List&lt;? extends Arc&gt; getArcs ();
  List&lt;? extends Arc&gt; getInputArcs (Node node);
  List&lt;? extends Arc&gt; getInputArcs (Node node, String arcName);
  List&lt;? extends Arc&gt; getOutputArcs (Node node);
  List&lt;? extends Arc&gt; getOutputArcs (Node node, String arcName);
  List&lt;? extends Node&gt; getStartNodes ();
  List&lt;? extends Node&gt; getNodes ();
}
</pre><p>
        A
        <code class="literal">Graph</code>
        contains instances of
        <code class="literal">Node</code>
        and
        <code class="literal">Arc</code>
        .
      </p><p>
        <code class="literal">Node</code>
        is where the developer can provide custom functionality, and has
        the following API:
      </p><pre class="programlisting">package com.googlecode.sarasvati;
public interface Node extends Adaptable
{
  String getName ();
  String getType ();
  boolean isJoin ();
  boolean isStart ();
  String getGuard ();
  Graph getGraph ();
  boolean isExternal ();
  GuardResponse guard (Engine engine, NodeToken token);
  void execute (Engine engine, NodeToken token);
}
</pre></div><div class="section" title="Flow of Execution"><div class="titlepage"><div><div><h3 class="title"><a name="using-flow-of-execution"></a>Flow of Execution</h3></div></div></div><p>
        When the engine determines that a node is ready to execute, it will
        follow this flow:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            Generate a
            <code class="literal">NodeToken</code>
            pointing to that node.
          </p></li><li class="listitem"><p>
            Execute the <code class="literal">guard</code>
            function on the node. This will return a
            <code class="literal">GuardResponse</code>.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                The
                <code class="literal">GuardResponse</code>
                contains a
                <code class="literal">GuardAction</code>
                , which is an enum having values
                <code class="literal">AcceptToken</code>
                ,
                <code class="literal">DiscardToken</code>
                and
                <code class="literal">SkipNode</code>
                .
              </p></li></ul></div></li><li class="listitem"><p>
            If the action is
            <code class="literal">AcceptToken</code>
            , the
            <code class="literal">execute</code>
            method will be called. The process will not continue until
            the
            <code class="literal">Engine#completeExecution</code>
            method is invoked. It must be invoked with the name of the
            arcs on which to generate
            <code class="literal">ArcToken</code>
            s.
          </p></li><li class="listitem"><p>
            If the action is
            <code class="literal">DiscardToken</code>
            , the token is marked complete and no further execution
            will take place from this set of tokens.
          </p></li><li class="listitem"><p>
            If the action is
            <code class="literal">SkipNode</code>
            ,
            <code class="literal">Engine.completeExecution</code>
            will be called with the arc name contained in the
            <code class="literal">GuardResponse</code>
            .
          </p></li></ol></div></div><div class="section" title="Custom logic for Node Execution"><div class="titlepage"><div><div><h3 class="title"><a name="using-custom-logic-node-execution"></a>Custom logic for Node Execution</h3></div></div></div><p>
        To provide custom behavior to your nodes, you will override the
        <code class="literal">execute</code>
        method on
        <code class="literal">Node</code>
        . Sarasvati currently provides two implementations of the base
        API, one memory backed and one database backed, implemented
        using Hibernate. Other implementations could be made using, for
        example, pure JDBC or some other persistence mechanism. There
        are three base classes for nodes.
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
            <code class="literal">com.googlecode.sarasvati.mem.MemNode</code>
          </p></li><li class="listitem"><p>
            <code class="literal">com.googlecode.sarasvati.hib.HibNode</code>
          </p></li><li class="listitem"><p>
            <code class="literal">com.googlecode.sarasvati.CustomNode</code>
          </p></li></ul></div><p>
        If using only the memory backed implementation,
        <code class="literal">MemNode</code>
        should be extended. If using only the hibernate backend, nodes
        should subclass <code class="literal">HibNode</code>.
        <code class="literal">CustomNode</code>
        can be used with either or both backends. In to store custom
        attributes in the database, it uses a key/value pair table.
        <code class="literal">CustomNode</code>
        can only be used if the database mapping doesn't need to be
        explicitly defined.
      </p><div class="section" title="Example One"><div class="titlepage"><div><div><h4 class="title"><a name="using-custom-example-one"></a>Example One </h4></div></div></div><p>
          To demonstrate use of each implementation, we start with a node that
          just prints out "Hello, World". We start with the process
          definition.
        </p><div class="section" title="Example One: Process Definition"><div class="titlepage"><div><div><h5 class="title"><a name="using-custom-example-one-proc-def"></a>Example One: Process Definition </h5></div></div></div><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;process-definition
  name="hello-world"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="hello" type="helloWorld" isStart="true"/&gt;

&lt;/process-definition&gt;
</pre></div><div class="section" title="Example One: Node implementation"><div class="titlepage"><div><div><h5 class="title"><a name="using-custom-example-one-node-impl"></a>Example One: Node implementation </h5></div></div></div><p>
            If using the memory implementation, the subclass would look like:
          </p><pre class="programlisting">
package com.googlecode.sarasvati.example.mem;

import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;
import com.googlecode.sarasvati.mem.MemNode;

public class HelloNode extends MemNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, world!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
</pre><p>
            The hibernate version would look like:
          </p><pre class="programlisting">
import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;

import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;
import com.googlecode.sarasvati.hib.HibNode;

@Entity
@DiscriminatorValue( "helloWorld" )
public class HelloNode extends HibNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, World!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
</pre><p>
            The hibernate version would also require an insert into the
            <code class="literal">wf_node_type</code>
            table, with type, description and behaviour.
          </p><pre class="programlisting">
insert into wf_node_type (id, description, behaviour)
 values ( 'helloWorld', 'Says hello to the world', 'helloWorld' )
</pre><p>
            The behaviour column ties the type to a discriminator specified on the
            subclass. This allows having multiple types with the same
            implementation class, if that was desired.
          </p><p>
            The backend independent version would look like:
          </p><pre class="programlisting">
import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.CustomNode;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;

public class HelloNode extends CustomNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, World!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
</pre><p>
            For use with the hibernate backend, a row would still need to be
            added to the <code class="literal">wf_node_type</code> table.
          </p><pre class="programlisting">
insert into wf_node_type (id, description, behaviour)
 values ( 'helloWorld', 'Says hello to the world', 'custom' )
</pre></div><div class="section" title="Example One: Loading and Running"><div class="titlepage"><div><div><h5 class="title"><a name="using-example-one-load-run"></a>Example One: Loading and Running</h5></div></div></div><p>
            Now we can load the process into memory, or into the database.
            This is done using a
            <code class="literal">GraphLoader</code>
            , which can be retrieved from the appropriate engine. Before
            loading the process definition, you will need to tell the engine
            about your custom node types.
          </p><p>
            The steps are
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                  Create an engine of the appropriate type
                </p></li><li class="listitem"><p>
                  Register custom node types
                </p></li><li class="listitem"><p>
                  Load the process definition from XML file
                </p></li><li class="listitem"><p>
                  Get the loaded graph from the graph repository associated with the
                  engine
                </p></li><li class="listitem"><p>
                  Start a new GraphProcess using the graph
                </p></li></ol></div><p>

            Here are the steps in code for the memory backed implementation.
          </p><pre class="programlisting">
    MemEngine engine = new MemEngine();

    // Tell engine about our custom node type
    engine.addNodeType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
</pre><p>
            Here are the steps in code for the hibernate backed
            implementation. It assumes that you have a means of creating a
            hibernate <code class="literal">Session</code> object.
          </p><pre class="programlisting">
    Session session = ...; // get hibernate session
    HibEngine engine = new HibEngine( session );

    // Tell engine about our custom node type
    engine.addNodeType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
</pre><p>
            Here are the steps in code using the backend independent custom
            type with <code class="literal">MemEngine</code>.
          </p><pre class="programlisting">
    MemEngine engine = new MemEngine();

    // We can either register the type with the Engine or with the DefaultNodeFactory
    // directly.
    // Either tell the engine about our custom node type
    engine.addGlobalCustomNodeType( "helloWorld", HelloNode.class );

    // or tell the DefaultNodeFactory about the node type directly
    DefaultNodeFactory.addGlobalCustomType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
</pre><p>
            The call to <code class="literal">startProcess</code>
            will create tokens on the start nodes and will continue
            executing the process until it completes or enters a wait state.
          </p></div></div></div><div class="section" title="Custom Attributes"><div class="titlepage"><div><div><h3 class="title"><a name="using-custom-attributes"></a>Custom Attributes</h3></div></div></div><p>
        Often, custom nodes will need some information with which to do their
        work. Sarasvati supports this in two ways.
      </p><p>
        The schema for process definition files has a
        <code class="literal">&lt;custom&gt;</code>
        element which contains an
        <code class="literal">&lt;xs:any&gt;</code>
        element at the end of the node definition. Custom elements may
        be added here. These can be automatically mapped to properties
        on custom nodes.
      </p><p>
        For example, given the following custom node:
      </p><pre class="programlisting">
public class CustomNode extends MemNode
{
  String foo;

  public String getFoo ()
  {
    return foo;
  }

  public void setFoo (String foo)
  {
    this.foo = foo;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    // do something ...
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
</pre><p>
        The following process definition would load the value
        <code class="literal">test</code> into the <code class="literal">custom</code>
        property.
      </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;process-definition
  name="example1"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="test" type="custom" isStart="true"&gt;
    &lt;arc to="1"/&gt;

    &lt;custom&gt;
      &lt;foo&gt;test&lt;/foo&gt;
    &lt;/custom&gt;
  &lt;/node&gt;
&lt;/process-definition&gt;
</pre><p>
        There several things to note with custom elements.
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
            All custom elements must be contained within the
            <code class="literal">&lt;custom&gt;</code> tag.
          </p></li><li class="listitem"><p>
            Non-string properties on custom node types are supported.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                Support for primitive types such as boolean, byte, char, short, int,
                long, float, double as well as their corresponding
                object types is built in.
          </p></li><li class="listitem"><p>
                Support for non-primitive types can be added
          </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                    Implement <code class="literal">com.googlecode.sarasvati.env.AttributeConverter</code>
                  </p></li><li class="listitem"><p>
                    Register the new mutator using the <code class="literal">setConverterForType</code> method (which takes
                    a class and an <code class="literal">AttributeConverter</code>) on
                    <code class="literal">com.googlecode.sarasvati.env.AttributeConverters</code>.
                  </p></li></ul></div></li></ul></div></li></ul></div><p>
        Nested objects are supported. For example:
      </p><pre class="programlisting">
  &lt;custom&gt;
    &lt;task&gt;
      &lt;name&gt;test&lt;/name&gt;
    &lt;/task&gt;
  &lt;/custom&gt;
</pre><p>
        The loader would invoke
        <code class="literal">getTask().setName( ... )</code>
        on the custom node.
      </p><p>
        Attributes are also supported. How they are mapped is based on the contents of
        the element the attribute is on. If the element has child
        elements, the attribute will get mapped as a child property. If
        the element is itself a property, the attribute name will be
        combined with the element name to get the property name.
      </p><pre class="programlisting">
  &lt;custom&gt;
    &lt;task user="pat"&gt;
      &lt;name&gt;test&lt;/name&gt;
    &lt;/task&gt;
  &lt;/custom&gt;
</pre><p>
        This would map the
        <code class="literal">name</code>
        element value to
        <code class="literal">getTask().setName( ... )</code>
        and the
        <code class="literal">user</code>
        attribute to
        <code class="literal">getTask().setUser( ... )</code>
        .
      </p><p>
        However, the following would be mapped differently:
      </p><pre class="programlisting">
  &lt;custom&gt;
    &lt;task user="pat"&gt;
      test
    &lt;/task&gt;
  &lt;/custom&gt;
</pre><p>
        This would map the text in the
        <code class="literal">task</code>
        element to
        <code class="literal">setTask( ... )</code>
        and the
        <code class="literal">user</code>
        attribute to
        <code class="literal">setTaskUser( ... )</code>
        .
      </p></div><div class="section" title="Custom Loader"><div class="titlepage"><div><div><h3 class="title"><a name="using-java-api-custom-loader"></a>Custom Loader</h3></div></div></div><p>
        You may also provide custom loading via a subclass of
        <code class="literal">NodeFactory</code>. It has the following interface:
      </p><pre class="programlisting">
public interface NodeFactory
{
  Node newNode (String type) throws LoadException;
  void loadCustom (Node node, Object custom) throws LoadException;
}
</pre><p>
        The custom data may be null, a single object, or a list of
        objects. The object or objects will either be elements of
        <code class="literal">org.w3c.dom.Element</code>
        or JAXB objects, if you have a JAXB mapping for your custom XML.
      </p><p>
        Instances of
        <code class="literal">NodeFactory</code>
        may be registered on
        <code class="literal">GraphLoader</code>
        .
      </p><div class="section" title="Example Two: Process Definition"><div class="titlepage"><div><div><h4 class="title"><a name="using-example-two-proc-def"></a>Example Two: Process Definition </h4></div></div></div><p>
          Here we examine a more complicated example, which uses custom
          attributes.
       </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;process-definition
  name="example1"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="start" isStart="true"&gt;
    &lt;arc to="1"/&gt;
  &lt;/node&gt;

  &lt;node name="1" type="task"&gt;
    &lt;arc to="2"/&gt;
    &lt;arc to="3"/&gt;

    &lt;custom&gt;
      &lt;taskName&gt;Enter order&lt;/taskName&gt;
      &lt;taskDesc&gt;
        Enter order and billing info
      &lt;/taskDesc&gt;
    &lt;/custom&gt;
  &lt;/node&gt;

  &lt;node type="task" name="2"&gt;
    &lt;arc to="4"/&gt;

    &lt;custom&gt;
      &lt;taskName&gt;Bill Customer&lt;/taskName&gt;
      &lt;taskDesc&gt;
        Bill the Customer
      &lt;/taskDesc&gt;
    &lt;/custom&gt;
  &lt;/node&gt;

  &lt;node type="task" name="3"&gt;
    &lt;arc to="4"/&gt;

    &lt;custom&gt;
      &lt;taskName&gt;Ship product&lt;/taskName&gt;
      &lt;taskDesc&gt;
        Package and ship product
      &lt;/taskDesc&gt;
    &lt;/custom&gt;
  &lt;/node&gt;

  &lt;node type="task" name="4" joinType="labelAnd"&gt;

    &lt;custom&gt;
      &lt;taskName&gt;Market to Customer&lt;/taskName&gt;
      &lt;taskDesc&gt;
        Send marketing material to customer
      &lt;/taskDesc&gt;
    &lt;/custom&gt;

  &lt;/node&gt;

&lt;/process-definition&gt;
</pre></div><div class="section" title="Example Two: Node implementation"><div class="titlepage"><div><div><h4 class="title"><a name="using-example-two-node-impl"></a>Example Two: Node implementation </h4></div></div></div><p>
          We will need a couple of classes to represent tasks and their state.
          First we look at the memory based implementation.
        </p><p>
          First we have an enum for task states.
          </p><pre class="programlisting">
public enum TaskState { Open, Completed, Rejected }
</pre><p>

          Next is the <code class="literal">Task</code> class.
        </p><pre class="programlisting">
public class Task
{
  protected NodeToken nodeToken;
  protected String name;
  protected String description;
  protected TaskState state;

  public Task (NodeToken nodeToken, String name, String description, TaskState state)
  {
    this.nodeToken = nodeToken;
    this.name = name;
    this.description = description;
    this.state = state;
  }

  public NodeToken getNodeToken ()
  {
    return nodeToken;
  }

  public void setNodeToken (NodeToken nodeToken)
  {
    this.nodeToken = nodeToken;
  }

  public String getName ()
  {
    return name;
  }

  public String getDescription ()
  {
    return description;
  }

  public TaskState getState ()
  {
    return state;
  }

  public void setState (TaskState state )
  {
    this.state = state;
  }

  public boolean isRejectable ()
  {
    Node node = getNodeToken().getNode();
    return !node.getGraph().getOutputArcs( node, "reject" ).isEmpty();
  }
}
</pre><p>
          In our simple example, we need some way of tracking which tasks have
          been created.
        </p><pre class="programlisting">
public class TaskList
{
  protected static List&lt;Task&gt; tasks = new LinkedList&lt;Task&gt;();

  public static List&lt;Task&gt; getTasks ()
  {
    return tasks;
  }
}
</pre><p>
          Finally, the custom node for generating tasks
        </p><pre class="programlisting">
public class TaskNode extends MemNode
{
  protected String taskName;
  protected String taskDesc;

  public String getTaskName ()
  {
    return taskName;
  }

  public void setTaskName (String taskName)
  {
    this.taskName = taskName;
  }

  public String getTaskDesc ()
  {
    return taskDesc;
  }

  public void setTaskDesc (String taskDesc)
  {
    this.taskDesc = taskDesc;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    Task newTask = new Task( token, getTaskName(), getTaskDesc(), TaskState.Open );
    TaskList.getTasks().add( newTask );
  }
}
</pre><p>
          When a task node is executed, it will create new
          <code class="literal">Task</code>
          instance and add it to a task list. A task can be completed or
          rejected as seen in the following code snippet:
        </p><pre class="programlisting">
      Task t = ...;

      if ( isCompletion )
      {
        t.setState( TaskState.Completed );
        engine.completeExecution( t.getNodeToken(), Arc.DEFAULT_ARC );
      }
      else if ( isReject &amp;&amp; t.isRejectable() )
      {
        t.setState( TaskState.Rejected );
        engine.completeExecution( t.getNodeToken(), "reject" );
      }
</pre><p>
          The primary difference with the database/Hibernate version, is
          that the node and tasks will require database backing. Let us
          look at the <code class="literal">TaskNode</code> class.
        </p><pre class="programlisting">
@Entity
@DiscriminatorValue( "task" )
@SecondaryTable( name="wf_node_task", pkJoinColumns=@PrimaryKeyJoinColumn(name="id"))
public class TaskNode extends HibNode
{
  @Column (name="name", table="wf_node_task")
  protected String taskName;

  @Column (name="description", table="wf_node_task")
  protected String taskDesc;

  public TaskNode() { /* Default constructor for Hibernate */ }

  public String getTaskName ()
  {
    return taskName;
  }

  public void setTaskName (String taskName)
  {
    this.taskName = taskName;
  }

  public String getTaskDesc ()
  {
    return taskDesc;
  }

  public void setTaskDesc (String taskDesc)
  {
    this.taskDesc = taskDesc;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    HibEngine hibEngine = (HibEngine)engine;

    Session session = hibEngine.getSession();

    TaskState open = (TaskState)session.load( TaskState.class, 0 );
    Task newTask = new Task( (HibNodeToken)token, getTaskName(), getTaskDesc(), open );
    session.save( newTask );
  }
}
</pre></div></div><div class="section" title="Environment"><div class="titlepage"><div><div><h3 class="title"><a name="using-java-api-env"></a>Environment</h3></div></div></div><p>
        It is often useful to track state associated with a process or tokens. Sarasvati
        provides several environments in which state can be placed. Some environments
        are defined solely by the contents of a process definition, and are therefore
        readonly. Readonly environments are represented by the
        <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/env/ReadEnv.html" target="_top">ReadEnv</a>
        interface. Most environments are read-write and are represented by the
        <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/env/Env.html" target="_top">Env</a> interface,
        which extends from <code class="literal">ReadEnv</code>.
      </p><p>
        The Env interface supports both persistent and transient attributes.

        </p><div class="table"><a name="id567244"></a><p class="title"><b>Table 4.10. Environment Attribute Types</b></p><div class="table-contents"><table summary="Environment Attribute Types" border="1"><colgroup><col width="60"><col></colgroup><thead><tr><th>Type</th><th>Behavior</th></tr></thead><tbody><tr><td>Persistent</td><td>
                  Must be serializable to the database. All primitives and object version of the primitives, as
                  well as String and Date are supported by default. Support for other types may be added
                  by defining an <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/env/AttributeConverter.html" target="_top">AttributeConverter</a>,
                  which is then registered with the
                  <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/env/AttributeConverters.html" target="_top">AttributeConverters</a> class,
                  using the <code class="literal">setConverterForType</code> method.
                </td></tr><tr><td>Transient</td><td>
                  Transient attributes are only stored as long as the process is in memory. They are a convenient places to cache values
                  during process execution. Because they aren't persisted to a database, there is no restriction on what types can
                  be stored.
                </td></tr></tbody></table></div></div><p><br class="table-break">
      </p><div class="section" title="Process Environment"><div class="titlepage"><div><div><h4 class="title"><a name="using-java-api-env-process"></a>Process Environment</h4></div></div></div><p>
          A process environment is read-write and is shared across an entire process.
        </p><pre class="programlisting">
  GraphProcess p = ...;
  Env env = p.getEnv();
  env.setAttribute( "foo", "test" );
  env.setAttribute( "bar", 5 );
  String foo = env.getAttribute( "foo" );
  int bar = env.getAttribute( "foo", Integer.class );
           
         </pre></div><div class="section" title="Node Token Environment"><div class="titlepage"><div><div><h4 class="title"><a name="using-java-api-env-token"></a>Node Token Environment</h4></div></div></div><p>
          The node token environment is read-write. Node token state is only visible to the
          given token, however tokens inherit the environment of their parents. Token state
          is initialized using the following rules:

          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
               If a token has no parents, it will start with an empty environment.
             </p></li><li class="listitem"><p>
               If a token has one parent, it will inherit the environment of its parent.
             </p></li><li class="listitem"><p>
               When a child token inherits the environment of it's parent, it may point directly
               to the parent's environment, until the child writes to the environment, at which
               point the environment will be copied. This means that if the parents writes to the
               environment after children have been created, and the children have not written
               to their environments, these changes will be visible to the children.
             </p></li><li class="listitem"><p>
               If a token has multiple parents parent, it will inherit the environment of its parent.
             </p></li><li class="listitem"><p>
               If a token has multiple parents parent with overlapping attribute names, the child
               environment wil get one the value from one of the parents, generally whichever is
               merged into the child environment last.
             </p></li></ul></div><p>
        </p><pre class="programlisting">
  NodeToken t = ...;
  Env env = t.getEnv();
  env.setAttribute( "foo", "test" );
  env.setAttribute( "bar", 5 );
  String foo = env.getAttribute( "foo" );
  int bar = env.getAttribute( "foo", Integer.class );

         </pre></div><div class="section" title="Combining Environment"><div class="titlepage"><div><div><h4 class="title"><a name="using-java-api-env-combining"></a>Combining Environment</h4></div></div></div><p>
          To read from both the process and node token environments, use the
          <code class="literal">NodeToken#getFullEnv()</code> method. It will return
          an <code class="literal">Env</code> which will read first from node token environment
          and, if no attribute is defined there, read from the process environment.
          All writes will affect the node token environment.
        </p><p>
          This is implemented using
          <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/impl/NestedEnv.html" target="_top">NestedEnv</a>,
          which can be used to stack any combination of environments.
        </p></div><div class="section" title="Token Set Environment"><div class="titlepage"><div><div><h4 class="title"><a name="using-java-api-env-token-set"></a>Token Set Environment</h4></div></div></div><p>
          When working with token sets, there are two environments available.

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>An environment shared by all tokens in the token set</p></li><li class="listitem"><p>
                An environment specific to each member index. For example, if a token set
                is generated with three members, then the first token will have index
                <code class="literal">0</code>, the second with have index <code class="literal">1</code>
                and the third will have index <code class="literal">2</code>. Any tokens generated
                from the first token will also have index <code class="literal">0</code>, until
                such point as the token set is joined and is marked complete.
              </p></li></ol></div><p>

          To see how token set environments are used, take as an example an approval process.
          The token set is generated as follows:

        </p><pre class="programlisting">
Map&lt;String,List&lt;?&gt;&gt; initialMemberEnv = new HashMap&lt;String, List&lt;?&gt;&gt;();
String[] groups = new String[] { "Accounting",
                                 "Security",
                                 "Operations" };
initialMemberEnv.put( "group", Arrays.asList( groups ) );

Env tokenSetEnv = new MapEnv();
tokenSetEnv.setAttribute( "deadline", 3 );

engine.completeWithNewTokenSet(
    token,           // the token being completed
    Arc.DEFAULT_ARC, // the name of the arc(s) to exit on
    "approvals",     // name to give the new token set
    3,               // number of tokens to generate on each arc
                     // with the given name
    true,            // completing asynchronously
    tokenSetEnv,     // initial token set env
    initialMemberEnv // token set member env
  );

         </pre><p>
           This generates a token set with three tokens in it. They all share a common <code class="literal">deadline</code>
           attribute, but each will see a different value for the <code class="literal">group</code> attribute. These
           attributes can be access from the tokens in the token set as follows:
         </p><pre class="programlisting">

// Access the token set environment
Env setEnv = token.getTokenSet( "approvals" ).getEnv();
int deadline = setEnv.getAttribute( "deadline", Integer.class );

// Access the environment specific to this token within the token set
Env env = token.getTokenSetMember( "approvals" ).getEnv();
String group = env.getAttribute( "group" );

         </pre></div><div class="section" title="Externals Environment"><div class="titlepage"><div><div><h4 class="title"><a name="using-java-api-env-externals"></a>Externals Environment</h4></div></div></div><p>
          When defining an external in a process definition, attributes may be defined
          for that external. Those attributes will be visible to nodes in the referenced
          external.

          In the following process definition, when node <code class="literal">A</code> is executed,
          it will print out the values defined for attributes named <code class="literal">foo</code>
          and <code class="literal">bar</code>. If the process definition were executed directly,
          both values would be undefined.

          </p><pre class="programlisting">

&lt;process-definition
  name="external-env-one"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="A" type="script"&gt;
    &lt;custom&gt;
      &lt;execute type="js"&gt;
        var env = token.getNode().getExternalEnv();
        System.out.println( "foo: " + env.getAttribute( "foo" ) );
        System.out.println( "bar: " + env.getAttribute( "bar" ) );
      &lt;/execute&gt;
    &lt;/custom&gt;
  &lt;/node&gt;
&lt;/process-definition&gt;

           </pre><p>

           Process definition <code class="literal">external-env-one</code> can be included in <code class="literal">external-env-two</code>,
           as demonstrated below. If executed, <code class="literal">foo</code> would now have the value
           <code class="literal">hello</code> and <code class="literal">bar</code> would have the value <code class="literal">world</code>.
          </p><pre class="programlisting">

&lt;process-definition
  name="external-env-two"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="B"&gt;
    &lt;arc external="one" to="A"/&gt;
  &lt;/node&gt;

  &lt;external name="one" processDefinition="external-env-one"&gt;
    &lt;custom&gt;
      &lt;foo&gt;hello&lt;/foo&gt;
      &lt;bar&gt;world&lt;/bar&gt;
    &lt;/custom&gt;
  &lt;/external&gt;

&lt;/process-definition&gt;

          </pre><p>
          The values defined for externals can be overriden. This can happen when the proces definition which
          defines the external is itself references as an external, as below. Now, <code class="literal">foo</code>
          will have the value <code class="literal">goodbye</code>, while <code class="literal">bar</code> will retain the
          value <code class="literal">world</code>.
          </p><pre class="programlisting">

&lt;process-definition
  name="external-env-three"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition"&gt;

  &lt;node name="C" isStart="true"&gt;
    &lt;arc external="two" to="B"/&gt;
  &lt;/node&gt;

  &lt;external name="two" processDefinition="external-env-two"&gt;
    &lt;custom&gt;
      &lt;foo&gt;goodbye&lt;/foo&gt;
    &lt;/custom&gt;
  &lt;/external&gt;

&lt;/process-definition&gt;

          </pre><p>
        </p></div></div><div class="section" title="Execution Listeners"><div class="titlepage"><div><div><h3 class="title"><a name="using-java-api-listeners"></a>Execution Listeners</h3></div></div></div><p>
        It is often useful to have a callback mechanism for various events in the execution of the
        workflow. Sarasvati allows registering listeners either globally or per-process. Support
        for specifying listeners per-graph will be forthcoming.
      </p><p>
        Execution listeners must implement the
        <a class="ulink" href="../../javadoc/com/googlecode/sarasvati/event/ExecutionListener.html" target="_top">ExecutionListener</a>
        interface. Because execution listeners may be added to processes that are serialized to a database,
        there are some rules around how they should be built.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Execution listeners are stored in the database simply by classname.
              They must therefore have a public default constructor.
            </p></li><li class="listitem"><p>
              Instances of an execution listeners may be shared across threads and should therefore
              be thread-safe. For performance reasons, they should ideally be stateless, allowing
              them to be unsychronized.
            </p></li></ol></div><p>

        Here is an example listener which prints out events as they occur.

        </p><pre class="programlisting">

package com.googlecode.sarasvati.example;

import com.googlecode.sarasvati.event.EventActions;
import com.googlecode.sarasvati.event.ExecutionEvent;
import com.googlecode.sarasvati.event.ExecutionListener;

public class LoggingExecutionListener implements ExecutionListener
{
  @Override
  public EventActions notify (final ExecutionEvent event)
  {
    System.out.println( event.getEventType() + ": " +
                        " Process: " + event.getProcess() +
                        " NodeToken: " + event.getNodeToken() +
                        " ArcToken: " + event.getArcToken() );
    return null;
  }
}

        </pre><p>

         This listener could be register for all processes as follows:

        </p><pre class="programlisting">

// Add listener for all event types
engine.addExecutionListener( LoggingExecutionListener.class );

// Add listener for only the arc token and node token completed events
engine.addExecutionListener( LoggingExecutionListener.class,
                             ExecutionEventType.ARC_TOKEN_COMPLETED,
                             ExecutionEventType.NODE_TOKEN_COMPLETED );

        </pre><p>

         One can also specify a particular process to listener to.

        </p><pre class="programlisting">

// Add listener for all event types
engine.addExecutionListener( process, LoggingExecutionListener.class );

// Add listener for only the arc token and node token completed events
engine.addExecutionListener( process, LoggingExecutionListener.class,
                             ExecutionEventType.ARC_TOKEN_COMPLETED,
                             ExecutionEventType.NODE_TOKEN_COMPLETED );

        </pre><p>

        Listeners aren't limited to a passive. In some cases they may
        affect workflow processing by returning a
        <code class="literal">EventActions</code> with an appropriate
        <code class="literal">EventActionType</code>. The actions that may be
        taken are:

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              An execution listener may prevent a process that is
              in pending complete state from moving to complete
              state. This is to allow end of workflow processing
              to happen asynchronously.
            </p></li><li class="listitem"><p>
              Similarly, an execution listener may prevent a process
              that is in pending cancel state from moving to cancelled
              state.
            </p></li><li class="listitem"><p>
              An execution listener may prevent a node token that has just
              been accepted into a node from executing. This may be used
              to implement delayed node execution based on timer.
            </p></li></ul></div><p>

        Here is a listener that creates and returns <code class="literal">EventActions</code>.

        </p><pre class="programlisting">

public class DelayExecutionListener implements ExecutionListener
{
  @Override
  public EventActions notify (final ExecutionEvent event)
  {
    if ( event.getEventType() ==
         ExecutionEventType.PROCESS_PENDING_COMPLETE )
    {
      return new EventActions(
        EventActionType.DELAY_PROCESS_FINALIZE_COMPLETE );
    }
    return null;
  }
}

        </pre><p>
      </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top"> Sarasvati File Format </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
